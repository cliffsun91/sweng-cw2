%% LyX 2.0.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{listings}
\usepackage{geometry}
\geometry{verbose,tmargin=4cm,bmargin=4cm,lmargin=2cm,rmargin=2cm}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{babel}






\usepackage{babel}




\usepackage{babel}


\makeatother

\usepackage{babel}
\begin{document}

\title{Software Engineering CW2}


\author{Abhijit Chandgadkar, Osama Javed, }


\author{Joseph Slade, Cliff Sun, Luke Tomlin}


\date{27/11/12}

\maketitle

\section*{Process}

Acting as a small team tackling a completely unfamiliar codebase,
we took several steps towards implementing the desired goal, keeping
in mind extra aims to improve the existing code, make it maintainable
and make it extendable.


\subsection*{Adding unit tests for existing functionality}


\paragraph*{What}

Whilst we had many ideas for improving the code itself, the most important
part was to make sure that we did not affect the existing functionality
beyond what we were asked to change, effectively 'freezing' the current
functionality. To do this, we began adding unit tests that tested
the existing functionality, so that we could easily verify that our
changes were not breaking anything. This was the first step to making
the code maintainable, much like we did in the first lecture tutorial
(Legacy Code). We decided to use $JUnit4$ to do our unit testing.


\paragraph*{How}

We had aspirations to restructure the project to make it more easily
maintainable - this meant that we had to add tests for all of the
areas that we were planning to touch. As an example, the project specification
had us editing the $BillingSystem$ class. Upon inspection, we decided
what responsibilities this class had: 
\begin{itemize}
\item Registers calls starting and ending between numbers 
\item Processes these calls and applies them as bills to the corresponding
customers from the customer database

\begin{itemize}
\item In doing so, it calculates the tariff rates and uses some algorithm
(which we were changing in the specification) to decide the final
cost of the call. 
\end{itemize}
\end{itemize}
Judging from these responsibilities, we added a variety of unit tests
covering basic and edge cases for each responsibility. For instance,
for $callInitiated$ and $callCompleted$, we added tests to make
sure that the specified events were added to the log. Additionally,
we fabricated some customer calls, with predefined times, and tested
these making sure that the resulting bill was equivalent to what we
expected. These calls were designed to cover all of the edge cases
as well, such as calls over peak time to off peak time and vice versa,
and calls of zero length, as well as extremely long calls. As an example,
here is where we check the edge case of the boundary times between
peak and offpeak: 
\begin{lstlisting}[language=Java]
@Test public void testIsOffPeakBoundaryTime() {
	// Check what happens on the limit of peak -> offpeak
	calendar.set(Calendar.HOUROFDAY, DaytimePeakPeriod.OFFPEAKSTART);
	assertTrue (peakPeriod.offPeak(calendar.getTime())); 
	calendar.set(Calendar.HOUROFDAY, DaytimePeakPeriod.OFFPEAKEND); 
	assertFalse (peakPeriod.offPeak(calendar.getTime())); 
} 
\end{lstlisting}



\subsection*{Forming specifications for new functionality}

In our project with Stephen, our entire project goals had been specified
by mouth only! As we saw in week 5 of the lecture (Spec by Example),
this is quite risky - we might completely misinterpret what Stephen
meant, and end up wasting time in the process. To remedy this, we
decided to create a simple DSL using JUnit, with which we created
some acceptance tests. This meant that the tests were easily readable,
simple to write, and were simple to demonstrate to Stephen and other
non-developers as an example of expected operation. The results of
these tests could also be printed as a normal bill.


\paragraph*{How}

Using parts of week 6's lectures (DSLs), we developed our own DSL.
Below is an example of one of the tests

\[
EXAMPLE
\]
 This was built up using $HOW\, IT\, WAS\, BUILT$


\subsection*{Adding unit tests for new functionality}

Before we could implement the required changes, we wanted to add unit
tests to cover what the expected outcome was going to be, as an example
of Test-Driven Development. This meant that we could repeatedly test
the code as we implemented it to ensure that the desired goal was
being fulfilled. We had to think carefully about what exactly to test,
to make sure that it completely covered every aspect of our goals.
We implemented the tests using the DSL that we developed earlier,
effectively connecting the new functionality tests with the specifications
that we were showing to Stephen.


\paragraph*{How}

\[
SOME\, TESTS
\]



\subsection*{Implementing new functionality}

By this point we were fairly confident that we had a good grasp of
the existing functionality that we needed to preserve, cemented by
unit tests, as well as a good vision of what we needed to add/change,
supported by the unit tests written in the DSL (which we would have
cleared with Stephen).


\paragraph*{What}

We needed to tweak how the calls were charged, which involved understanding
exactly how long a call was in peak and offpeak periods and tallying
the results accordingly. This involved recoding how $BillingSystem$
worked, as well as adding additional functionality to $DaytimePeakPeriod$.


\paragraph*{How}

\[
EXAMPLE\, OF\, NEW\, IMPLEMENTATION
\]


\[
DISCUSSION
\]



\subsection*{Refactoring code to improve maintainability and code health}

The existing code had multiple problems that we aimed to fix over
the course of the project. These were not all related to the goals
set out by Stephen, but as we would be looking after the codebase
for the forseeable future we decided that it would be wise to improve
the general health of the codebase to reduce headaches later. Some
examples: 
\begin{itemize}
\item The $DaytimePeakPeriod$ class, which handled deciding whether calls
were onpeak or offpeak, was very rigidly implemented. The times for
the boundary between offpeak and peak were defined as ``magic numbers''
inside the code (in this case as 7 and 19, representing 7am and 7pm
respectively). This left no room for providing flexible peak and offpeak
times without directly editing the class itself. Additionally, if
different tariffs could have different peak times, perhaps changing
more than once throughout the day, it would require a whole overhaul
of the class. 
\item The $CallStart$ and $CallEnd$ classes, used $System.currentTimeMillis$
to get the time of call and end. This made testing difficult - to
construct a call using this implementation would require the test
to $sleep$ inbetween calling and ending the call, which would make
the testing process very slow indeed! This occurs in the $Runner$
example provided in the specification - it takes a full 1 minute and
50 seconds to complete!
\item The $BillingSystem$ was responsible for registering and handling
$CallEvent$ happenings, which we felt was somewhat outside of its
domain of responsibility. We felt that a system that is designed for
billing should handle just that - it should take a list of pre-assembled
calls, and work out the bills from that. 
\item Additionally, the $BillingSystem$ was woefully inefficient at creating
the bills for customers. In the original state, it would iterate through
every customer, and then through every $CallEvent$ that had been
logged, and assemble each call that way. Assuming the system has $1000$
customers, and each customer makes $100$ calls over the course of
the month, that means each customer adds $200$ different events to
the $callLog$, for a total of $200000$ call events. That means that
the $BillingSystem$ makes a total of $1000\, customers\times200000\, events=200,000,000$
iterations to assemble one bill for all of its customers! Even generating
a single bill takes $20000$ iterations, making this system very difficult
to scale. This isn't even the worst case - the way the system is designed,
it searches the whole $callLog$ every time!
\end{itemize}

\paragraph*{How}

We added an $AbstractCallEvent$ as an abstract interface implementing
the $CallEvent$ interface, and then changed $CallStart$ and $CallEnd$
to implement this. This let us write tests a lot easier (rather than
having to rely on $sleep$!), by letting us fabricate times as we
wanted and then test it using the standard functions. Additionally,
we implemented the common $getCaller$ and $getCallee$ methods that
were being duplicated in both $CallStart$ and $CallEnd$ inside the
$AbstractCallEvent$ class, reducing the code size and making it easier
to read. As an example, this reduced the $CallStart$ class to simply
being

\begin{lstlisting}[language=Java]
public class CallEnd extends AbstractCallEvent {
	public CallEnd(String caller, String callee) {
		super(caller, callee, System.currentTimeMillis());
	}
}
\end{lstlisting}
With the $BillingSystem$ class, we removed the 
\[
METHODS\, WE\, REMOVED/IMPROVEMENTS
\]



\section*{Considerations}

Whilt we were implementing the required changes and tweaking the codebase,
we thought of a variety of other considerations that should be considered.
We also implemented some of these whilst we were coding, but some
of the other ones were outside the scope of the coursework itself,
but should have been considered in the theoretical Acme Telecom scenario.


\subsection*{Source control}

When we first received the code from Stephen, it was simply emailed
as a tarball. Keeping the code like this was definitely sub-optimal,
so we decided to host it in some form of source control (in our project
we used GitHub for ease of use - but in the context of Acme Telecom
we would most likely have used a private version!). This made collaboration
between the team members much easier, as well as keeping a timeline
of changes made to allow rollbacks.


\subsection*{Architecture changes}

We made multiple architectural changes to the code over the course
of the project - we altered where some of the files were placed, based
on responsibilities, as well as adding testing and resource directories.
For instance, we moved calling-based and call-event-based classes
away from normal telecom-based classes into a seperate package, modularising
the codebase and making it easier for multiple people to work on different
areas of the program.


\subsection*{Licensing}

Some care needed to be used when thinking about what OpenSource software
we wanted to use. If any of these had a 'viral' license (such as the
GNU General Public License), which require all derivative works to
also be licensed with the GPL, then the whole project itself would
have to be licensed with the GPL! This might prove to be problematic
in a private company with proprietary software, as they most likely
do not want competitors to be able to freely use their software. We
had to consider this risk when deciding to use Joda Time, for instance.
Fortunately, Joda Time uses the Apache 2 license, which is not 'viral'
and only requires that derivative work contains notifications of what
was changed, as well as retaining all other copyright, patent, trademark
notices etc. that existed in the original.


\subsection*{Building}

Maven


\subsection*{Deployment}

Continuous integration - git push / TeamCity linked to pom.xml

Whilst we did not actually implement any deployment mechanisms, we
did consider what deployment mechanisms would be appropriate for Acme
Telecom in the case of this product. Given the suite of tests that
we created testing for both the new and the old functionality, and
our use of Maven and git for source control and building, we thought
that it would be best to use TeamCity, much like we did in week 7's
tutorial (Release). It would be fairly simple to set up as we already
had git and Maven configured, and assuming that management was happy
with the quality of the tests that we put in place, would make releasing
very simple and quick. We assumed that the Acme company has access
to its own set of servers, and we would use those to deploy on. 
\end{document}
