%% LyX 2.0.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{listings}
\usepackage{geometry}
\geometry{verbose,tmargin=4cm,bmargin=4cm,lmargin=2cm,rmargin=2cm}
\usepackage{url}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{babel}






\usepackage{babel}




\usepackage{babel}

\makeatother

\usepackage{babel}
\begin{document}

\title{Software Engineering CW2}


\author{Abhijit Chandgadkar, Osama Javed, Joseph Slade, Cliff Sun, Luke Tomlin}


\date{06/12/12}

\maketitle

\section*{Process}

Acting as a small team tackling a completely unfamiliar codebase,
we took several steps towards implementing the desired goal, keeping
in mind extra aims to improve the existing code, make it maintainable
and make it extendable.


\subsection*{Adding unit tests for existing functionality}


\paragraph*{What}

Whilst we had many ideas for improving the code itself, the most important
part was to make sure that we did not affect the existing functionality
beyond what we were asked to change, effectively 'freezing' the current
functionality. To do this, we began adding unit tests that tested
the existing functionality, so that we could easily verify that our
changes were not breaking anything. This was the first step to making
the code maintainable, much like we did in the first lecture tutorial
(Legacy Code). We decided to use $JUnit4$ to do our unit testing,
with some help from $JMock$.


\paragraph*{How}

We had aspirations to restructure the project to make it more easily
maintainable - this meant that we had to add tests for all of the
areas that we were planning to touch. As an example, the project specification
had us editing the $BillingSystem$ class. Upon inspection, we decided
what responsibilities this class had: 
\begin{itemize}
\item Registers calls starting and ending between numbers 
\item Processes these calls and applies them as bills to the corresponding
customers from the customer database

\begin{itemize}
\item In doing so, it reads the tariff rates and uses them with some algorithm
(which we were changing in the specification) to decide the final
cost of the call. 
\end{itemize}
\end{itemize}
Judging from these responsibilities, we added a variety of unit tests
covering basic and edge cases for each responsibility. For instance,
for $callInitiated$ and $callCompleted$, we added tests to make
sure that the specified events were added to the log. Additionally,
we fabricated some customer calls, with predefined times, and tested
these making sure that the resulting bill was equivalent to what we
expected. These calls were designed to cover all of the edge cases
as well, such as calls over peak time to off peak time and vice versa,
and calls of zero length, as well as extremely long calls. As an example,
here is where we check the functionality of the $Call$ class: 
\begin{lstlisting}[language=Java]
final Mockery context = new Mockery(); 	
final CallEvent callStart = context.mock(CallEvent.class, "CallEvent1"); 	
final CallEvent callEnd = context.mock(CallEvent.class, "CallEvent2"); 	
final Call call = new Call(callStart, callEnd); 
	
@Test 	
public void testGetCalleeGetsCalleeFromCallStart(){ 		
	final String callee = "Cliff"; 	
	context.checking(new Expectations() {{             
		oneOf(callStart).getCallee(); 
		will(returnValue(callee));         
	}}); 	
	Assert.assertThat(call.callee(), CoreMatchers.equalTo(callee));	 	
}
\end{lstlisting}



\subsection*{Forming specifications for new functionality}

In our project with Stephen, our entire project goals had been specified
by mouth only! As we saw in week 5 of the lecture (Spec by Example),
this is quite risky - we might completely misinterpret what Stephen
meant, and end up wasting time in the process. To remedy this, we
decided to create a simple DSL using JUnit, with which we created
some acceptance tests. This meant that the tests were easily readable,
simple to write, and were simple to demonstrate to Stephen and other
non-developers as an example of expected operation. The results of
these tests could also be printed as a normal bill.


\paragraph*{Acceptance tests}

Writing acceptance tests is crucial for both development and the business.
For developers it provides validation that a particular feature works
across the whole system. For the business it tells them that the feature
has been successfully imple mented and can be released to production.
In our case, it is important to write acceptance tests f or the new
functionality that we are required to implement, it allows our customer
Stephen to see whether new functionality works and lets him know the
progress of development. However we are also trying to add tests to
the legacy code and so it is also important to write acceptance tests
for the current functionality as well.


\paragraph*{How}

Using parts of week 6's lectures (DSLs), we developed our own DSL
to perform the acceptance tests. Below is an example of one of the
tests

\begin{lstlisting}[language=Java,showstringspaces=false]
// Creating a new customer database
customerDatabase = createNewDatabaseWithCustomers(aCustomer(named("James"),  					   													withTelephoneNumber("+447567891234"),  					   													withTariffPlan("Standard")), 					   									  aCustomer(named("Fred"),  					   													withTelephoneNumber("+447912345678"),  					   													withTariffPlan("Standard")));

// Testing the final bill printed
givenAcmeTelecom().hasCustomerDatabase(customerDatabase).
	andHasABillingSystem(
	billingSystem().withTelephoneCalls(telephoneCalls)
				   .withABillPrinter(aStandardPrinter())
	).
	weExpectTheFollowingBillToBePrinted("foo").assertResult();
\end{lstlisting}
The benefits of such an acceptance test system are immediately obvious
- it lets someone without any prior knowledge of how Java works or
of how the system is set up, understand what the tests are doing -
a developer could run through this code with Stephen or any other
project manager, and change the acceptance tests (and ultimately the
code itself to adhere to the tests). This was built up using a combination
of builder patterns (for building the tests from the DSL), fixtures
(for running the tests), and microtypes (to make the DSL more readable). 


\paragraph*{Choice}

We can choose a variety of acceptance test frameworks to write out
tests with. Frameworks like Behave, FIT and Cucumber are well supported
and widely used but often come with a lot of setting up nd have features
that are not necessary. Especially in our case as we only need to
test that we charge the correct amount depending on the peak period.
So in our case it would be beneficial to write out own DSL to create
acceptance tests with. We also use the JUnit framework to create our
internal Domain Specific Language which we will then use to write
the acceptance tests. The advantage is that we can run the acceptance
tests along with the unit tests and means it works well if we were
to use continuous integration. Also, as we are doing this in an IDE,
we have the advantages of auto-complete / content assist and syntax
checking.


\subsection*{Adding unit tests for new functionality}

Before we could implement the required changes, we wanted to add unit
tests to cover what the expected outcome was going to be, as an example
of Test-Driven Development. This meant that we could repeatedly test
the code as we implemented it to ensure that the desired goal was
being fulfilled. We had to think carefully about what exactly to test,
to make sure that it completely covered every aspect of our goals.
We implemented the tests using the DSL that we developed earlier,
effectively connecting the new functionality tests with the specifications
that we were showing to Stephen.


\paragraph*{How}

\begin{lstlisting}[language=Java]
@Test     
public void testCallCostWithStandardTariff() throws Exception {     	
	PeakOffPeakTime peakOffPeakTime = new PeakOffPeakTime(100, 200);     	
	Tariff tariff = Tariff.Standard;     	
	BigDecimal cost = 
		new DefaultCallCostCalculator().calculateCost(peakOffPeakTime, tariff); 	Assert.assertEquals(cost.longValue(), 90);     
}	
\end{lstlisting}



\subsection*{Implementing new functionality}

By this point we were fairly confident that we had a good grasp of
the existing functionality that we needed to preserve, cemented by
unit tests, as well as a good vision of what we needed to add/change,
supported by the unit tests written in the DSL (which we would have
cleared with Stephen).


\paragraph*{What}

We needed to tweak how the calls were charged, which involved understanding
exactly how long a call was in peak and offpeak periods and tallying
the results accordingly. This involved recoding how $BillingSystem$
worked, as well as moving and/or adding functionality to $DaytimePeakPeriod$.


\paragraph*{How}

We created a new package called timeutils, which abstracted the required
peak/offpeak time calculations out from the billing system. Careful
consideration went into building the package, making sure that it
would be easily scalable and configurable. For instance, we added
the ability to define different xml files for peak/offpeak configuration,
which are read in at run-time, and they also allow multiple peak and
offpeak times to be specified for the same day.

Originally we considered making the time calculation methods static,
to improve performance - however after rethinking the issue we decided
to use interfaces and objects as this is much easier to scale and
extend. If the underlying implementation needs to change at any point
(eg. implementing a different kind of calculator), as long as they
abide by the interface rules everything will still work. 

This package was developed in a test-driven-development style - unit
tests were specified once the planning had finished, and were coded
to cover the entire scope of the specification. The result of this
was that we could be confident that the required functionality was
intact as we went about developing the package.

The end result was a change in how $BillingSystem$ worked, as well
as removing a lot of the responsibility that it previously had. It
fundamentally performed the same task, however it now did so more
efficiently, and in a much clearer and concise manner.


\subsection*{Refactoring and improving code to aid maintainability and code health}

The existing code had multiple problems that we aimed to fix over
the course of the project. These were not all related to the goals
set out by Stephen, but as we would be looking after the codebase
for the forseeable future we decided that it would be wise to improve
the general health of the codebase to reduce headaches later. Some
examples: 
\begin{itemize}
\item The $DaytimePeakPeriod$ class, which handled deciding whether calls
were onpeak or offpeak, was very rigidly implemented. The times for
the boundary between offpeak and peak were defined as ``magic numbers''
inside the code (in this case as 7 and 19, representing 7am and 7pm
respectively). This left no room for providing flexible peak and offpeak
times without directly editing the class itself. Additionally, if
different tariffs could have different peak times, perhaps changing
more than once throughout the day, it would require a whole overhaul
of the class. 
\item The $CallStart$ and $CallEnd$ classes, used $System.currentTimeMillis$
to get the time of call and end. This made testing difficult - to
construct a call using this implementation would require the test
to $sleep$ inbetween calling and ending the call, which would make
the testing process very slow indeed! This occurs in the $Runner$
example provided in the specification - it takes a full 1 minute and
50 seconds to complete!
\item The $BillingSystem$ was responsible for registering and handling
$CallEvent$ happenings, which we felt was somewhat outside of its
domain of responsibility. We felt that a system that is designed for
billing should handle just that - it should take a list of pre-assembled
calls, and work out the bills from that. 
\item Additionally, the $BillingSystem$ was woefully inefficient at creating
the bills for customers. In the original state, it would iterate through
every customer, and then through every $CallEvent$ that had been
logged, and assemble each call that way. Assuming the system has $1000$
customers, and each customer makes $100$ calls over the course of
the month, that means each customer adds $200$ different events to
the $callLog$, for a total of $200000$ call events. That means that
the $BillingSystem$ makes a total of $1000\, customers\times200000\, events=200,000,000$
iterations to assemble one bill for all of its customers! Even generating
a single bill takes $20000$ iterations, making this system very difficult
to scale. This isn't even the worst case - the way the system is designed,
it searches the whole $callLog$ every time!
\end{itemize}

\paragraph*{How}

We performed many different changes to the code, with the aim to fix
the above problems, or at least make them more manageable. Some of
the main things we changed include:


\subparagraph*{Call Events}

We added an $AbstractCallEvent$ as an abstract interface implementing
the $CallEvent$ interface, and then changed $CallStart$ and $CallEnd$
to implement this. This let us write tests a lot easier (rather than
having to rely on $sleep$!), by letting us fabricate times as we
wanted and then test it using the standard functions. Additionally,
we implemented the common $getCaller$ and $getCallee$ methods that
were being duplicated in both $CallStart$ and $CallEnd$ inside the
$AbstractCallEvent$ class, reducing the code size and making it easier
to read. As an example, this reduced the $CallStart$ class to simply
being

\begin{lstlisting}[language=Java]
public class CallEnd extends AbstractCallEvent {
	public CallEnd(String caller, String callee) {
		super(caller, callee, System.currentTimeMillis());
	}
}
\end{lstlisting}



\subparagraph*{BillingSystem}

With the $BillingSystem$ class, we made a lot of changes. From the
performance perspective, we moved the calculation of bills from call
events to happen as the calls come in - this made it far more efficient
when bill generation was required, effectively making it linear in
size of customer base as compared to polynomial! From the structure
perspective, as mentioned above, we moved a lot of the functionality
elsewhere and made its responsibilities more specific. Additionally,
we added a large amount of extra functionality to the existing system,
such as allowing for flexible peak/offpeak time periods, or even multiple
peak/offpeak time periods! These can be defined at run-time using
xml, and were implemented using the $JAXB$ java architecture for
xml bindings. Basic validation of these files is done at runtime to
ensure that they are properly formed, and helps prevent user-created
errors.


\subparagraph*{Joda Time}

One big change that we made to the code was to introduce Joda Time
(\url{http://joda-time.sourceforge.net/}) in place of $java.util.Date$.
This had many advantages, above and beyond simply being easier to
use. It has a lot more flexibilty and power than $Date,$ allowing
us to work dates and times in a more concise manner without having
to wrestle with $Calendars$ and $SimpleDateFormat$ classes. Another
big thing to consider was the fact that $SimpleDateFormat$ is not
thread safe! As handling dates and times is so integral to the code,
if we wanted to implement any sort of multi-threading functionality
to the code we would have to completely remove $SimpleDateFormat$. 


\section*{Statistics}

dependency diagram, test-coverage


\section*{Considerations}

Whilst we were implementing the required changes and tweaking the
codebase, we thought of a variety of other considerations that should
be considered. We also implemented some of these whilst we were coding,
but some of the other ones were outside the scope of the coursework
itself, but should have been considered in the theoretical Acme Telecom
scenario.


\subsection*{Source control}

When we first received the code from Stephen, it was simply emailed
as a tarball. Keeping the code like this was definitely sub-optimal,
so we decided to host it in some form of source control (in our project
we used GitHub for ease of use - but in the context of Acme Telecom
we would most likely have used a private version!). This made collaboration
between the team members much easier, as well as keeping a timeline
of changes made to allow rollbacks.


\subsection*{Architecture changes}

We made multiple architectural changes to the code over the course
of the project - we altered where some of the files were placed, based
on responsibilities, as well as adding testing (acceptance or unit-based)
and resource directories. For instance, we moved calling-based and
call-event-based classes away from normal telecom-based classes into
a seperate package, moved the entirety of offpeak/peak cal calculations
out to a seperate utils class, amongst other things, modularising
the codebase and making it easier for multiple people to work on different
areas of the program, as well as making the code conceptually easier
to understand. 


\paragraph*{Wrappers}

We found that testing was a little bit challenging, as the customer
database that was supplied to us was located outside of the package.
We considered creating a wrapper around the functionality of the database,
which we could use as an interface to create dummies of the database
for testing and mocking without having to touch the 'real' databases
whilst doing tests. However, we didn't have enough time to fully implement
these wrappers, as the underlying functionality that it would need
to fulfill was too complicated for us to get a grasp of in a short
time-frame. Fortunately this doesn't translate too badly into real
life, as the database accesses that are performed from the tests are
minor, but this could be problematic if the databases are ever down
and we need to do tests!


\subsection*{Multi-Threading}

The act of generating multiple bills appears to lend itself quite
well to a multi-threaded approach. Each bill being generated could
be classified as a unit of operation, and the whole process could
be split across multiple computers. We did not get around to implementing
multithreading to the system, but it would certainly be something
to consider in the future if running time ever became a problem. 


\subsection*{Licensing}

Some care needed to be used when thinking about what OpenSource software
we wanted to use. If any of these had a 'viral' license (such as the
GNU General Public License), which require all derivative works to
also be licensed with the GPL, then the whole project itself would
have to be licensed with the GPL! This might prove to be problematic
in a private company with proprietary software, as they most likely
do not want competitors to be able to freely use their software. We
had to consider this risk when deciding to use Joda Time, for instance.
Fortunately, Joda Time uses the Apache 2 license, which is not 'viral'
and only requires that derivative work contains notifications of what
was changed, as well as retaining all other copyright, patent, trademark
notices etc. that existed in the original.

Maven also helps us with licensing - it can keep track of license
for different parts of the projects, and notify us of clashes in licensing. 


\subsection*{Building}

For build automation we decided to use Maven, as the team was already
mostly familiar with its usage from previous tutorials, and because
of how well it licensingtied in with TeamCity for continuous integration.
Additionally, it allowed the import of our project as a dependency,
so it could be easily used in other projects (such as extensions of
the billing system or similar).


\subsection*{Deployment}

Whilst we did not actually implement any deployment mechanisms, we
did consider what deployment mechanisms would be appropriate for Acme
Telecom in the case of this product. Given the suite of tests that
we created testing for both the new and the old functionality, and
our use of Maven and git for source control and building, we thought
that it would be best to use TeamCity, much like we did in week 7's
tutorial (Release). It would be fairly simple to set up as we already
had git and Maven configured, and assuming that management was happy
with the quality of the tests that we put in place, would make releasing
very simple and quick. We assumed that the Acme company has access
to its own set of servers, and we would use those to deploy on.

Maven also acts as a form of internal deployment - it lets us deploy
to an internal 'Maven repository'. Internal users who wish to use
the latest version of our project simply add the project as a dependency
to their project, and Maven then automatically imports the latest
version of the jars and sets it up.
\end{document}
